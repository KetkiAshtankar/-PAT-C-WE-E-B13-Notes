
# ðŸ“˜ Python OOP Concepts 
---

## ðŸ”¹ Class â†’ Blueprint

A **class** is like a **blueprint** for creating objects.

```python
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
```

---

## ðŸ”¹ Object â†’ Instance of a class

An **object** is something we build from a class.

```python
car1 = Car("Toyota", "Fortuner")
print(car1.brand)   # Toyota
```

---

## ðŸ”¹ Encapsulation â†’ Data hiding

We hide data using **private variables** (start with `__`).

```python
class Bank:
    def __init__(self, balance):
        self.__balance = balance   # private

    def show_balance(self):
        return self.__balance

acc = Bank(5000)
print(acc.show_balance())   # 5000
```

---

## ðŸ”¹ Inheritance â†’ Code reuse

A **child class** can reuse the code from a **parent class**.

```python
class Animal:
    def speak(self):
        return "Some sound"

class Dog(Animal):   # Inherits from Animal
    def speak(self):
        return "Bark"

dog = Dog()
print(dog.speak())   # Bark
```

---

## ðŸ”¹ Polymorphism â†’ Same method, different behavior

Different classes can have methods with the **same name**, but they work differently.

```python
class Cat:
    def speak(self):
        return "Meow"

class Dog:
    def speak(self):
        return "Bark"

for animal in [Cat(), Dog()]:
    print(animal.speak())
```

ðŸ‘‰ Output:

```
Meow
Bark
```

---

## ðŸ”¹ Abstraction â†’ Hiding details

We show only the **important part** and hide the rest using `abstract classes`.

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

dog = Dog()
print(dog.sound())   # Bark
```

---

## ðŸ”¹ Constructor (`__init__`) â†’ Initializes object

Runs automatically when an object is created.

```python
class Student:
    def __init__(self, name):
        self.name = name

s1 = Student("Rahul")
print(s1.name)
```

---

## ðŸ”¹ Destructor (`__del__`) â†’ Cleans up object

Runs automatically when an object is deleted.

```python
class Test:
    def __del__(self):
        print("Object destroyed")

obj = Test()
del obj   # Object destroyed
```

---

## ðŸ”¹ self â†’ Current object reference

`self` represents the **object that is calling the method**.

```python
class Person:
    def __init__(self, name):
        self.name = name
    
    def show(self):
        print("My name is", self.name)

p = Person("Amit")
p.show()
```

---

## ðŸ”¹ Static Method â†’ No `self` or `cls`

Does not need object or class reference.

```python
class Math:
    @staticmethod
    def add(a, b):
        return a + b

print(Math.add(5, 3))   # 8
```

---

## ðŸ”¹ Class Method â†’ Works with `cls`

Works with the class itself, not the object.

```python
class Student:
    school = "ABC School"

    @classmethod
    def get_school(cls):
        return cls.school

print(Student.get_school())   # ABC School
```

---

# ðŸŽ¯ Summary

* **Class** â†’ Blueprint
* **Object** â†’ Instance
* **Encapsulation** â†’ Hide data (`__private`)
* **Inheritance** â†’ Code reuse (Parent â†’ Child)
* **Polymorphism** â†’ Same method, different behavior
* **Abstraction** â†’ Hide implementation details
* **Constructor** â†’ Initialize object (`__init__`)
* **Destructor** â†’ Cleanup (`__del__`)
* **self** â†’ Current object
* **Static Method** â†’ Independent function
* **Class Method** â†’ Works with class

---
